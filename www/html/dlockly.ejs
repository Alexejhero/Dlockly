<%- include ("partials/head") %>
<%- include ("partials/blockly") %>

<html style="overflow:hidden;">

<div class="body">

  <table>
    <tbody>
      <tr><td>
        <div style="font-size:30px;display:inline-block;"><%= guildName %> </div>
        <div style="font-size:20px;display:inline-block;color:gray;">(<%= guildId %>)</div>
        <br>
        <a href="/"><button>Back to server list</button></a>
        <% if (invite) { %>
          <a href="invite?guild=<%= guildId %>"><button>Generate invite</button></a>
        <% } %>
        <br>
        <br>
        <form action="/save" method="post" onsubmit="saveConfig()">
          <input type="hidden" name="guild" id="inputGuild" required>
          <input type="hidden" name="xml" id="inputXml" required>
          <input type="submit" id="save" value="Save Configuration">
          <button type="button" id="reset" onclick="resetConfig()">Reset Changes</button>
          <button type="button" id="example" onclick="loadExample()">Load Example</button>
          <a href="/shop?guild=<%= guildId %>"><button type="button" id="shop" style="float:right;"><% if (!premium) { %>Get<% } else { %>Manage<% } %> Premium</button></a>
        </form>
        <hr>
      </td></tr>
      <tr><td id="blocklyArea"></td></tr>
      <tr><td style="padding-bottom:38px;"></td></tr>
    </tbody>
  </table>

  <div id="blocklyDiv" style="position:absolute"></div>
  <xml id="toolbox" style="display: none">
    <%- xmlCategoryTree %>
  </xml>

</div>

<%- include ("partials/footer") %>

<script>
  document.getElementById("blocklyDiv").style.height = window.innerHeight - 20 + "px";
  document.getElementById("blocklyDiv").style.width = window.innerWidth - 20 + "px";

  <% for (var v of blocks) { %>
    <% if (v.default) continue; %>
    Blockly.Blocks["<%= v.type %>"] = { 
      init: function () {
        this.jsonInit(JSON.parse(decode('<%= JSON.stringify(v) %>')));
      },
    };
  <% } %>

  <% generators.forEach(g => { %>
    Blockly.JavaScript['<%= g.type %>'] = function(block) {
      var _return;
      eval(decode("<%= g.generator %>"));
      return _return;
    }
  <% }); %>

  <% for (var v of blocks) { %>
    <% if (!v.optionalReturn) continue; %>
    Blockly.Extensions.registerMutator("<%= v.type %>_optional_return_mutator", {
      mutationToDom: function() {
        if (!this.getConnectionType()) return;

        var mutation = Blockly.utils.xml.createElement("mutation");
        mutation.setAttribute("connection", this.getConnectionType());
        
        return mutation;
      },

      domToMutation: function(xml) {
        switch (this.getConnectionType()) {
          case 0: {
            if (!this.outputConnection) this.outputConnection = new Blockly.RenderedConnection(this, 2);
            if (!this.previousConnection) this.previousConnection = new Blockly.RenderedConnection(this, 4);
            if (!this.nextConnection) this.nextConnection = new Blockly.RenderedConnection(this, 3);
            break;
          }
          case 1: {
            if (!this.outputConnection) this.outputConnection = new Blockly.RenderedConnection(this, 2);
            if (this.previousConnection) {
              if (this.previousConnection.isConnected()) this.previousConnection.disconnect();
              this.previousConnection = null;
            }
            if (this.nextConnection) {
              if (this.nextConnection.isConnected()) this.nextConnection.disconnect();
              this.nextConnection = null;
            }
            break;
          }
          case 2: {
            if (this.outputConnection) {
              if (this.outputConnection.isConnected()) {
                this.outputConnection.disconnect();
              }
              this.outputConnection = null;
            }
            if (!this.previousConnection) this.previousConnection = new Blockly.RenderedConnection(this, 4);
            if (!this.nextConnection) this.nextConnection = new Blockly.RenderedConnection(this, 3);
            break;
          }
          default: {
            if (this.outputConnection) {
              if (this.outputConnection.isConnected()) this.outputConnection.disconnect();
            } else {
              this.outputConnection = new Blockly.RenderedConnection(this, 2);
            }
            if (this.previousConnection) {
              if (this.previousConnection.isConnected()) this.previousConnection.disconnect();
            } else {
              this.previousConnection = new Blockly.RenderedConnection(this, 4);
            }
            if (this.nextConnection) {
              if (this.nextConnection.isConnected()) this.nextConnection.disconnect();
            } else {
              this.nextConnection = new Blockly.RenderedConnection(this, 3);
            }
          }
        }
      },

      getConnectionType: function() {
        if (!this.icann(this.outputConnection) && !this.icann(this.previousConnection) && !this.icann(this.nextConnection)) return 0;
        if (this.icann(this.outputConnection) && !this.icann(this.previousConnection) && !this.icann(this.nextConnection)) return 1;
        if (!this.icann(this.outputConnection) && (this.icann(this.previousConnection) || this.icann(this.nextConnection))) return 2;
        return -1;
      },

      // isConnectedAndNotNull
      icann: function(connection) {
        return connection && connection.isConnected();
      }
    });
  <% } %>

  var blocklyArea = document.getElementById('blocklyArea');
  var blocklyDiv = document.getElementById('blocklyDiv');
  var workspace = Blockly.inject(blocklyDiv, {
    maxInstances: JSON.parse(decode('<%= max %>')),
    collapse: false,
    comments: false,
    grid: {
      spacing: 20,
      length: 1,
      color: '#888'
    },
    disable: false,
    scrollbars: true,
    toolbox: document.getElementById('toolbox'),
  });
  document.workspace = workspace;

  var onresize = function(e) {
    var element = blocklyArea;
    var x = 0;
    var y = 0;
    do {
      x += element.offsetLeft;
      y += element.offsetTop;
      element = element.offsetParent;
    } while (element);
    blocklyDiv.style.left = x + 'px';
    blocklyDiv.style.top = y + 'px';
    blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';
    blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';
    Blockly.svgResize(workspace);
  };
  window.addEventListener('resize', onresize, false);
  onresize();
  Blockly.svgResize(workspace);

  document.restrictions = JSON.parse(decode('<%= restrictions %>'));

  workspace.addChangeListener(Blockly.Events.disableOrphans);

  if (decode('<%= blocklyXml %>').length > 0) Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(decode("<%= blocklyXml %>")), workspace);

  setInterval(() => { 
    disableUnapplicable({ 
      type: Blockly.Events.MOVE, 
      workspaceId: workspace.id, 
    });

    var saveNeedsDisabling = false;
    if (decode("<%= blocklyXml %>") == Blockly.Xml.domToText(Blockly.Xml.workspaceToDom(workspace))) {
      document.getElementById("save").setAttribute("title", "You haven't made any changes!");
      document.getElementById("save").setAttribute("disabled", "true");
      document.getElementById("reset").setAttribute("title", "You haven't made any changes!");
      document.getElementById("reset").setAttribute("disabled", "true");
      saveNeedsDisabling = true;
    }
    for (var block of workspace.getAllBlocks(false)) {
      if (block.warning && !block.disabled) {
        document.getElementById("save").setAttribute("title", "Cannot save if there are errors!");
        document.getElementById("save").setAttribute("disabled", "true");
        return;
      }
    }
    if (!saveNeedsDisabling) {
      document.getElementById("save").removeAttribute("title");
      document.getElementById("save").removeAttribute("disabled");        
      document.getElementById("reset").removeAttribute("title");
      document.getElementById("reset").removeAttribute("disabled");
    }

    if (decode("<%= exampleXml %>") == Blockly.Xml.domToText(Blockly.Xml.workspaceToDom(workspace))) {
      document.getElementById("example").setAttribute("title", "The example is already loaded!");
      document.getElementById("example").setAttribute("disabled", "true");
    } else {
      document.getElementById("example").removeAttribute("title");
      document.getElementById("example").removeAttribute("disabled");
    }

    if (document.getElementById("save").hasAttribute("disabled"))
      window.onbeforeunload = null;
    else
      window.onbeforeunload = () => "You have unsaved changes!";
  }, 100);

  function saveConfig() {
    var code = Blockly.Xml.domToText(Blockly.Xml.workspaceToDom(workspace));
    document.getElementById("inputGuild").setAttribute("value", getUrlParameter("guild"));
    document.getElementById("inputXml").setAttribute("value", encodeURIComponent(code));
    window.onbeforeunload = null;
  }

  function resetConfig() {
    window.onbeforeunload = null;
    window.location.reload(false);
  }

  function loadExample() {
    document.workspace.clear();
    Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(decode("<%= exampleXml %>")), workspace);
  }

  data = {
    req: {
      body: {
        guild: "<%= guildId %>"
      }
    }
  }

  var generate = function () {
    postprocess(Blockly.JavaScript.workspaceToCode(workspace)).then(res => console.log(res.toString()));
  }

  async function postprocess(js) {
    var txt = (await fetch("postprocess?js=" + encodeURIComponent(js))).text();
    return txt;
  }
</script>